<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        class MyPromiss{
            constructor(excutor){
                console.dir(constructor)
                console.log(excutor)
                // 每创建一个构造函数就默认让constructor中的代码执行一次
                // constructor代表当前类的构造函数，如果需要传参则在constructor后的（）传参，所以excutor => function(resolve,reject){}，excutor执行传的参数则是传给了这个函数
                // 构造函数中的this指向当前实例
                this.state = 'pending';

                // 事件池中的数据是执行then的时候push的，不调用then事件池是没有内容的
                // 执行resolve和reject是让状态改变，且执行then中对应的方法，但是在执行resolve的时候then还没有执行，所以事件池是的，为了实现这个功能，把事件池中数据的执行做成异步，调用then的时候先改变状态，再执行then，再执行事件池中的方法
                this.fulfilledEvent = [];
                this.rejectedEvent = [];
                
                let resolve = (result) => {
                    if(this.state !== 'pending') return;
                    this.state = 'fulfilled';
                    clearTimeout(this.timer);
                    this.timer = setTimeout(() => {
                        this.fulfilledEvent.forEach((item) => {
                            if(typeof item === 'function'){
                                item(result);
                            }
                        })
                    })
                }

                let reject = (result) => {
                    if(this.state !== 'pending') return;
                    this.state = 'rejected';
                    clearTimeout(this.timer);
                    this.timer = setTimeout(() => {
                        this.rejectedEvent.forEach((item) => {
                            if(typeof item === 'function'){
                                item(result);
                            }
                        })
                    },0)
                }

                try{
                    excutor(resolve,reject);
                }catch(e){
                    // 如果excutor在执行的过程中直接执行reject方法，且把错误信息当做参数传给reject
                    reject(e);
                }
            }

            then(resolveFn,rejectFn){
                // 如果调用了then但是没有传参，为了避免报错为then的参数 resolveFn和rejectFn 赋值为空的函数
                if(resolveFn === 'undefined'){
                    resolveFn = () => {}
                }
                if(rejectFn === 'undefined'){
                    rejectFn = () => {}
                }
                return new MyPromiss(function(resolve,reject){
                    this.fulfilledEvent.push((result) => {
                        try{
                            let x = resolveFn(result);
                            x instanceof MyPromiss?x.then(resolve,reject):resolve();
                        }catch(e){
                            reject(e);
                        }
                    });
                    this.rejectedEvent.push((result) => {
                        try{
                            let x = rejectFn(result);
                            x instanceof MyPromiss?x.then(resolve,reject):resolve();
                        }catch(e){
                            reject(e);
                        }
                    });
                })
            }
        }    
        let p = new MyPromiss(function(resolve,reject){

        })
        p.then(function(){
            // return new MyPromiss(function(resolve,reject){

            // })
        },function(){

        }).then(function(){

        },function(){
            
        })

        let x = new Promise(function(resolve,reject){
            resolve();
        });
        x.then(function(){
            console.log(1)
        },function(){

        }).then(function(){
            console.log(2)
        },function(){

        })
    </script>
</body>
</html>